---
layout: post
title: "[Clean Architecture] SOLID - DIP 의존성 역전 원칙"
data: "2022-03-10 23:37:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 의존성 역전 원칙 Dependency Inversion Principle

고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.

<br>

의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 **소스 코드 의존성이 추상abstraction에 의존하며 구체concretion에는 의존하지 않는 시스템**이다.
의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소다. 이 구체적인 요소는 자주 변경될 수 밖에 없는 모듈들이다.

<br>

# 안정된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 변경될 필요가 없다.
-> `인터페이스는 구현체보다 변동성이 낮다.`

<br>

인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력하고 이는 소프트웨어 설계의 기본이다.

<br>

안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일을 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처다. 구체적인 코딩 실천법으로 다음과 같이 요약할 수 있다.

- **변동성이 큰 구체 클래스를 참조하지 말라.** 대신 추상 인터페이스를 참조하라. 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.
- **변동성이 큰 구체 클래스로부터 파생하지 말라.**
- **구체 함수를 오버라이드 하지 말라.** 구체 함수는 소스 코드 의존성을 필요로 하기 때문에 구체 함수 오버라이시 의존성 또한 상속하게 된다. 의존성을 제거하기 위해서는 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
- **구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.**

<br>

# 팩토리

안정된 추상화를 위한 규칙들을 준수하기 위해서는 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다. 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하기 때문이다.

<br>

자바 등 대다수의 객체 지향 언어에서는 바람직하지 못한 의존성을 처리할때 추상 팩토리를 사용하곤 한다.

<br>

<img width="100%" src="{{ "/assets/images/2022-03-10-6/1.jpg" | relative_url }}" />

- 곡선은 아키텍처 경계를 뜻한다. 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다. 소스코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.
- 곡선은 시스템을 추상 컴포넌트와 구체 컴포넌트로 분리한다. 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함하며, 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.
- 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 '의존성 역전 Dependency Inversion'이라고 부른다.

## 구체 컴포넌트

- ServiceFactoryImpl 컴포넌트에는 구체적인 의존성(ConcreteImpl)이 있고 이는 DIP에 위배된다. 하지만 이는 일반적이고 DIP 위배를 모두 없앨 수 있다. 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과 분리할 수 있다.
- 대부분의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함하며, 흔히 이 컴포넌트를 메인(Main)이라고 부른다.
- 이 경우에는 main 함수는 ServiceFactoryImpl 인스턴스를 생성한 후, 이 인스턴스를 ServiceFactory 타입으로 전역 변수에 저장할 것이고 Application은 이 전역 변수를 이용하여 ServiceFactoryImpl의 인스턴스에 접근할 것이다.
- 의존성은 이 곡선의 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙 Dependency Rule 이라 부를 것이다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
