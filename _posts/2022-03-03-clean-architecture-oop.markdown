---
layout: post
title: "[Clean Architecture] 객제 지향 프로그래밍"
data: "2022-03-03 00:10:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 개요

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발한다.

<br>

**객체 지향(이하 OO)**의 본질을 설명하기 위해 세 가지 주문에 기대는 부류도 있는데 `캡슐화 encapsulation`, `상속 inheritance`, `다형성 polymolphism`이다.

<br>

# 캡슐화

객체 지향(이하 OO)을 정의하는 요소 중 하나로 **캡슐화**를 언급하는 이유는 **데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공**하기 때문이다. 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.

<br>

C 언어에서는 데이터 구조와 함수를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현했다. 완벽한 캡슐화가 이뤄졌었다. 하지만 C++에서는 멤버 변수 또한 헤더파일에 넣었고 점점 캡슐화가 약해졌다.

<br>

# 상속

OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 OO 언어가 확실히 제공했다. 하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. OO언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다고는 말할 수 있지만 상속을 흉내내는 요령일뿐 상속만큼은 편리한 기법이 아니었다.

<br>

# 다형성

함수를 가리키는 포인터를 응용한 것이 다형성이다. OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다. 함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식은 위험하다. 이들 포인터를 초기화하는 관례를 준수해야 한다. 또한 이들 포인터를 통해 모든 함수를 호출하는 관례를 지켜야 한다.

<br>

OO 언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없어졌다.

## 다형성이 가진 힘

플러그인으로 다형성이 가진 힘을 알 수 있다. 왜 유닉스 운영체제는 입출력 장치들을 플로그인 형태로 만들었는가? 프로그램이 장치 독립적이어야 한다는 사실을 깨달았기 때문이다.

<br>

플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현됐다. 그럼에서 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지는 않았다. 함수를 가리키는 포인터를 사용하면 위험을 수반하기 떄문이다.

<br>

하지만 OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

## 의존성 역전

OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다. 소스 코드 의존성은 소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수있다. 이러한 접근법을 사용한다면, OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.

<br>

즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 호출하는 모듈이든 아니면 호춟 받는 모듈이든 관계업시 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.

<br>

# 결론

OO 란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

<br>

OO를 사용하면 아키텍트는 플러그인 아키텍쳐를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
