---
layout: post
title: "[Clean Architecture] SOLID - LSP 리스코프 치환 원칙"
data: "2022-03-10 22:50:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 리스코프 치환 원칙 Liskov Substitution Principle

1988년 바바라 리스코프는 하위 타입 subtype을 아래와 같이 정의했다.
`여기에서 필요한 것은 다음과 같은 치환 substitution 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.`

<br>

# 상속을 사용하도록 가이드하기

Billing 애플리케이션이 있다. 이 앱의 설계는 다음과 같다.

- Licence 클래스의 calcFee() 메서드를 호출한다.
- License 클래스에는 PersonalLicense와 BusinessLicense라는 두 가지 '하위타입'이 존재한다.

이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 의존하지 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.

<br>

# 정사각형/직사각형 문제

LSP를 위반하는 전형적인 문제로는 유명한 정사각형/직사각형 문제가 있다.
정사각형은 직사각형의 하위 타입으로 적절하지 않다. 직사각형의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, 정사각형의 높이와 너비는 반드시 함께 변경되기 때문이다.
<br>
정사각형은 직사각형으로 치환되지 못한다. 하위 타입이 상위 타입을 치환하지 못하는 문제가 생긴다. 이 문제를 해결하기 위해서 직사각형인지 정사각형인지 구분하는 코드를 정사각형과 직사각형 인스턴스를 포함하는 클래스에 추가하면 되지만 이럴 경우 이 클래스의 행위가 이 정사각형과 직사각형의 타입에 의존하게 되고 결국 타입도 치환할 수는 없다.

<br>

# LSP와 아키텍처

- LSP는 상속을 사용하도록 가이드하는 방법 정도록 간주되었으나, 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 설계 원칙으로 변모되었다.
- 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환이 가능하다.

<br>

# 결론

- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍쳐가 오염되어 상당량의 별도 메커니즘을 추가해야 할수도 있기 때문이다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
