---
layout: post
title: "[Clean Architecture] 구조적 프로그래밍"
data: "2022-03-03 00:01:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 구조적 프로그래밍의 탄생

데이스크트라의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만듬으로써 증명이라는 방법을 사용하여 프로그래머들이 쉽게 프로그래밍을 가능케 했다.

- 공리: 두 점이 주어졌을 때 두 점을 지나는 직선이 하나밖에 없다는 명제와 같이 증명할 수 없는 것
- 정리: 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제
- 따름정리: 정리를 통해 자연스럽게 도출되는 정리
- 도움정리: 정리를 증명하는데 필요한 정리

<br>

데이스크트라는 수학자가 유클리드 계층구조를 사용하는 방식을 프로그램도 사용할 수 있다고 믿었다. 다시 말해 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 스스로 증명하게 되는 방식이었다.

데이스크트라는 goto문의 ‘좋은’ 사용 방식은. it/then/esle와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당하는 사실을 발견했다. 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해 보였다.

그는 이러한 제어 구조는 순차 실행 sequential execution과 결합했을 때 특별하다는 사실을 깨달았다.

뵘과 야코피니는 순차 sequence, 분기 selection, 반복 iteration 이라는 세 지 구조만으로 모든 프로그램을 표현할 수 있다는 사실을 증명했다.

<br>

이러한 발견은 **모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일**하다는 사실이었다. 구조적 프로그램은 이렇게 탄생했다.

<br>

# 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있었고, 이는 결국 모둘을 기능적으로 분해할 수 있게 되었다. 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할수 있다. 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있다. 게다가 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.

<br>

이를 토대로 구조적 분석 structured analysis이나 구조적 설계 structured design 같은 기번이 인기를 끌었고 이들 기법을 사용하면 프로그래먼느 대규머 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

<br>

# 과학이 구출하다.

데이스크트라가 꿈꿨던 증명은 이뤄지지 않았다. 프로그래머는 세세한 기능 하나하나를 증명하지는 않았다. 엄밀한 증명이 고품질의 소프트웨어를 의미하지는 않는다.

<br>

수학적 증명 대신 과학적 방법이 있다. 과학은 근복적으로 수학과 다른데, 과학 이론과 법칙은 그 올바름을 절대 증명할 수 없기 때문이다. **과학적 방법은 반증은 가능하지만 증명은 불가능하다.**

<br>

수학은 증명 가능한 서술이 참이라는 것은 입증하는 원리라고 볼 수 있지만, **과학은 증명 가능한 서술이 거짓임을 입증하는 원리다.**

<br>

# 테스트

**프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.** 소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니라는 사실이다. 오히려 소프트웨어는 과학과 같다. 최선을 다하더라도 올바르지 않음을 증명하는데 실패함으로써 올바름을 보여주기 때문이다.

<br>

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그리고 나서 **테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도**한다. 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

<br>

# 결론

구조적 프로그래밍이 오늘날까지 가치있는 이유는 **프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력** 때문이다. 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 한다.

<br>

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 해야한다. 이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
