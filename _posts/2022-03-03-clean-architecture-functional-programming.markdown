---
layout: post
title: "[Clean Architecture] 함수형 프로그래밍"
data: "2022-03-03 00:20:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 개요

함수형 프로그래밍 패러다임에서 핵심이 되는 기반은 람다 계산법이다.

<br>

**객체 지향(이하 OO)**의 본질을 설명하기 위해 세 가지 주문에 기대는 부류도 있는데 `캡슐화 encapsulation`, `상속 inheritance`, `다형성 polymolphism`이다.

<br>

# 불변성과 아키텍처

아키텍트는 왜 **변수의 가변성**을 염려하는가? **경합 조건 race, 교착 상태 deadlock 조건, 동시 업데이트 concurrent update 문제가 모두 가변 변수로 인해 발생하기 때문**이다. 만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않는다. 락이 가변적이지 않아면 교착상태도 일어나지 않는다.

<br>

다수의 스레드와 프로세스를 사용하는 동시성 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.

<br>

# 가변성의 분리

애플리케이션 내부에서 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이 필요하다.

<br>

불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 상태 변경은 컴포넌트를 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다. 트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리 변수를 처리한다. 즉, 트랜잭션을 사용하거나 또는 재시도 기법을 통해 이들 변수를 보호한다.

<br>

**애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리**해야 한다는 것이다. 그리고 그렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다. **최대한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.**

<br>

# 이벤트 소싱

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랙잭션을 처리한다. 애플리케이션은 CRUD가 아니고 CR이다. 소스 코드 버전 관리 시스템이 이 방식으로 동작한다.

<br>

# 결론

- 구조적 프로그래밍은 제어흐름의 즉접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

<br>

세 패러다임 모두 우리가 코드를 작성하는 방식의 형태를 한정시킨다. 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.소프트웨어는 급격히 발전하는 기술이 아니다. 과거와 지금의 소프트웨어 규칙은 조금도 다르지 않다.

<br>

소프트웨어, 즉 컴퓨터 프로그램은 순차 sequence, 분기 selection, 반복 iteration, 참조 indirection로 구성된다. 그 이상도 이하도 아니다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
