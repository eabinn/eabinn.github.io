---
layout: post
title: "[Clean Architecture] 컴포넌트 원칙"
data: "2022-03-10 23:53:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 컴포넌트 원칙 Component Principle

- SOLID 원칙이 벽과 방에 벽돌을 배치할 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 알려준다.
- 큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

<br>

# 컴포넌트

컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.

- 컴파일형 언어에서는 바이너리 파일의 결합체
- 인터프리터형 언어의 경우는 소스 파일의 결합체
- 모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자

컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 `독립적으로 배포 가능`한, 따라서 `독립적으로 개발 가능`한 능력을 갖춰야 한다.

<br>

# 컴포넌트의 간략한 역사

프로그램이 로드될 주소를 선언하는 origin 구문이 나와야 했다. 프로그램의 위치가 한번 결정되면, 재배치가 불가능했다.

라이브러리를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다. 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.

하지만 이 방법은 컴파일이 너무 오래 걸렸고, 따라서 라이브러리를 컴파일해서 바이너리를 메모리의 특정 위치에 넣고 애플리케이션을 따로 컴파일해서 특정 위치에 넣었다. Application과 Function Library가 위치해야 하는 곳을 지정했다. 하지만 애플리케이션이 커지면서 결국 할당된 주소를 넘게 되었다.

애플리케이션을 두 개의 세그먼트 주소를 분리하여 함수 라이브러리 공간을 사이에 두고 동작하도록 하였다. 하지만 애플리케이션이 커지면서 결국 할당된 주소를 넘게 되었다.

프로그램과 라이브러리가 사용하는 메모리가 늘어날수록 이와 같은 단편화는 계속됐다.

## 재배치성

해결책은 재배치가 가능한 바이너리 reloacatable binary 였다.

지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이다. 이때 로더는 재배치 코드가 자리할 위치 정보를 전달받았다. 그리고 재배치 코드에는 로드한 데이터에서 어느 부분을 수정해야 정해진 주소에 로드할 수 있는지를 알려주는 플래그가 삽입되었다. 대개 이러한 플래그는 바이너리에서 참조하는 메모리의 시작 주소였다.

프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다. 로더는 여러 개의 바이너리를 하나씩 차례대로 메모리에 로드하면서 재배치하는 작업을 처리했다. 이를 통해 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다.

또한 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다. 프로그램이 라이브러리 함수를 호출하면 컴파일러는 외부 함수 이름을 외부 참조 external referece로 생성했다.

반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의 external definition로 생성했다. 이렇게 외부 정의를 로드할 위치가 정해지기만 하면 외부 참조를 외부 정의에 링크시킬 수 있게 된다. 이렇게 '링킹 로더 Linking Loader'가 탄생했다.

## 링커

링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.

하지만 이 시기에 라이브러리는 느린장치에 저장되었고 외부 참조를 해석하기 위해 외부 정의를 읽는데 너무 오랜 시간이 걸렸다.

로드와 링크가 분리되었다. 링커 Linker 라는 별도의 애플리케이션으로 느린 이 작업을 처리하도록 했다. 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌다.

하지만 점점 더 커지는 프로그램에 컴파일-링크 시간은 더 느려졌다.

하지만 Moore의 법칙이 말했던 것처럼 컴퓨터와 장치가 빨라져서 또다시 로드와 링크를 동시에 할 수 있게 되었다. 다수의 .jar 파일 또는 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었고 이렇게 컴포넌트 플러그인 아키텍처 Component Plugin Architecture가 탄생했다.

<br>

# 결론

- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
