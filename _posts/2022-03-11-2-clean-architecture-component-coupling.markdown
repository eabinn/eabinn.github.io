---
layout: post
title: "[Clean Architecture] 컴포넌트 결합"
data: "2022-03-11 07:24:00 +0900"
tags: [all, cleanArchitecture, book]
comments: true
---

해당 포스트는 Robert C. Martin의 Clean Architecture 저서를 읽고 정리했다.
<br>
<br>

# 컴포넌트 결합

컴포넌트 결합은 컴포넌트 사이의 관계를 개발 가능성과 논리적 설계 사이의 균형을 다룬다.

<br>

# ADP: 의존성 비순환 원칙 (Acyclic Dependencies Principle)

`컴포넌트 의존성 그래프에 순환 cycle이 있어서는 안된다.`

- '숙취 증후군'은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다. 이 문제에 대해 두 가지 방법이 해결책으로 발전해왔다. 첫 해결책은 '주 단위 빌드 weekly build', 두 번째 해결책은 '의존성 비순환 원칙 Acyclic Dependencies Principle. ADP'다.

## 주 단위 빌드 (Weekly Build)

- 각자 개발하고 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 이 해결책은 위기를 초래하는데, 호율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다. 통합과 테스트를 수행하기가 점점 더 어려워지고, 팀은 빠른 피드백이 주는 장점을 잃는다.

## 순환 의존성 제거하기

주 단위 빌드 문제점의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.

1. 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.
2. 담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다.
3. 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정하고 나머지 개발자는 릴리스 버전을 사용한다.

<br>

이 해결책을 통해 어떤 팀도 다른 팀에 의해 좌우되지 않는다. 각 팀은 특정 컴포넌트가 새롭게 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다. 또한 통합은 작고 점진적으로 이뤄진다.

<br>

하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. **의존성 구조에 순환이 있어서는 안된다**.

<br>

아래는 전형적인 컴포넌트 다이어그램이다.
<img width="100%" src="{{ "/assets/images/2022-03-11-2/1.png" | relative_url }}" />

- 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다. 비순환 방향 그래프다.
- 시스템 전체를 릴리스 해야할 때가 오면 릴리스 절차는 상향식으로 진행된다.
- 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.

## 순환이 컴포넌트 의존성 그래프에 미치는 영향

- Entitiles의 User 클래스가 Authorizer의 Permissions 클래스를 사용한다고 하자. 그럼 순환의존성이 발생한다. Entitles, Authorizer, Interactors가 사실상 하나의 거대한 컴포넌트가 되어 버린다.
- 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기 힘들어진다.

## 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제나 가능하다.

1. 의존성 역전 원칙 DIP 를 적용한다. User가 필요로 하는 메스드를 제공하는 인터페이스를 생성한다. 그리고 이 인터페이스를 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 상속받는다. 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고 이를 통해 순환을 끊을 수 있다. Authorizer가 Entites에 의존적이게 된다.
2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

## 흐트러짐 (Jitters)

- 두 해결책이 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 것이다.
- 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다. 순환이 발생하면 어떤 식으로든 끊어야 한다.

## 하향식(top-down) 설계

컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진행한다.

<br>

프로젝트가 점차 가지면 의존성 관리에 대한 요구가 점차 늘어나고 변경 단위가 시스템의 작은 일부로 한정되길 원한다. -> 단일책임원칙 SRP 와 공통 폐쇄 원칙 CCP 를 적용, 변경되는 클래스는 같은 위치에 배치되도록 원한다. -> 프로젝트가 점차 커짐에 따라 재사용 가능한 요소를 만드는 일에 관심을 기울인다. 공통 재사용 원칙 CRP이 영향을 미친다. -> 순환이 발생하게 되면 ADP가 적용된다. -> 컴폰넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.

<br>

# SDP: 안정된 의존성 원칙 (Stable Dependencies Principle)

`안정성의 방향으로 (더 안정된 쪽에) 의존해라`

- 안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

<br>

## 안정성

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

## 안정성 지표

컴포넌트로 들어오고 나가는 의존성의 개수를 세어 안정성을 측정할 수 있다.

- Fan-in: 안으로 들어오는 의존성. 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
- Fan-out: 바깥으로 나가는 의존성. 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 의미한다.
- I(불안전성): I = _Fan-out_ / \**( *Fan-in* + *Fan-out\* ). 이 지표는 [0, 1] 범위의 값을 갖는다. I=0이면 최고로 안정된 컴포넌트라는 뜻이다.

## 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.

<br>

안정된 컴포넌트에서 불안정한 컴포넌트로 의존성이 생기게 되면 DIP 를 사용하자.

## 추상 컴포넌트

추상 컴포넌트는 상당히 안정적이고 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.

<br>

# SAP: 안정된 추상화 원칙 (Stable Abstractions Principle)

`컴포넌트는 안정된 정도만큼만 추상화되어야 한다.`

<br>

## 고수준 정책을 어디에 위치시켜야 하는가?

시스템에는 자주 변경해서는 절대로 안 되는 소프트웨어(고수준 아키텍처나 정책 결정과 관련된 소프트웨어)도 있다. 이런 소프트웨어는 I=0 (안정된 컴포넌트)에 위치해야 한다.

<br>

하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드를 수정하기가 어려워진다. 시스템 전체 아키텍처가 유연성을 잃는다.

<br>

**컴포넌트가 최고로 안정된 상태(I=0)이면서 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?**
-> 개방 폐쇄 원칙 OCP 에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스르 유연하게 만들 수 있을 뿐만 아니라 바람적인 방식이다.(추상 abstract 클래스가 이 원칙을 준수한다.)

<br>

## 안정된 추상화 원칙

안정된 추상화 원칙 Stable Abstractions Principle, SAP은 안정성과 추상화 정도 사이의 관계를 정의한다.

<br>

이 원칙은 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다. 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있기 때문이다.

<br>

따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.

<br>

SAP와 SDP를 결합하면 컴포넌트에 대한 DIP와 마찬가지다. SDP와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.

<br>

---

### 저서

- <a href="https://martinfowler.com" target="_blank">Martin C.Fowler</a>의 Clean Architecture

<br>

---
